from __future__ import annotations


def emit_client_init(sync: bool) -> list[str]:
    """Generate the __init__ and helper methods for a client class.

    This includes:
    - __init__ with base_url, backend, headers, and raise_on_unexpected_status
    - _build_url for URL construction with path/query params
    - _encode_body for body serialization
    - _decode_body for response deserialization
    - _encode_ndjson for NDJSON encoding
    - _encode_multipart for multipart form encoding
    - _iter_event_stream_lines for SSE parsing (sync)
    - _aiter_event_stream_lines for SSE parsing (async)
    """
    backend_type = "SyncBackend" if sync else "AsyncBackend"
    return [
        "    def __init__(",
        "        self,",
        "        base_url: str,",
        f"        backend: {backend_type},",
        "        headers: Mapping[str, str] | None = None,",
        "        raise_on_unexpected_status: bool = True,",
        "    ) -> None:",
        "        self._base_url = base_url.rstrip('/')",
        "        self._backend = backend",
        "        self._headers = dict(headers or {})",
        "        self._raise_on_unexpected_status = raise_on_unexpected_status",
        "        self._expected_statuses = EXPECTED_STATUSES",
        "        self._accept_types = ACCEPT_TYPES",
        "        self._request_content_types = REQUEST_CONTENT_TYPES",
        "",
        "    def _build_url(",
        "        self,",
        "        path: str,",
        "        path_params: Mapping[str, JsonValue] | None,",
        "        query_params: Mapping[str, JsonValue] | None,",
        "    ) -> str:",
        '        url = f"{self._base_url}{path}"',
        "        if path_params:",
        "            for key, value in path_params.items():",
        "                url = url.replace(f'{{{key}}}', str(value))",
        "        if query_params:",
        "            query = urlencode(query_params, doseq=True)",
        "            if query:",
        '                url = f"{url}?{query}"',
        "        return url",
        "",
        "    def _encode_body(",
        "        self,",
        "        body: object | None,",
        "        content_type: str | None,",
        "    ) -> tuple[bytes | None, str | None]:",
        "        if body is None:",
        "            return None, content_type",
        "        if isinstance(body, bytes):",
        "            return body, content_type",
        "        if content_type and content_type.startswith('application/x-www-form-urlencoded'):",
        "            if isinstance(body, Mapping):",
        "                return urlencode(body, doseq=True).encode('utf-8'), content_type",
        "            return str(body).encode('utf-8'), content_type",
        "        if content_type and content_type.startswith('multipart/form-data'):",
        "            if isinstance(body, Mapping):",
        "                data, boundary = self._encode_multipart(body)",
        "                return data, f'{content_type}; boundary={boundary}'",
        "            return str(body).encode('utf-8'), content_type",
        "        if content_type and content_type.startswith('application/x-ndjson'):",
        "            return self._encode_ndjson(body), content_type",
        "        if content_type and content_type.startswith('application/stream+json'):",
        "            return self._encode_ndjson(body), content_type",
        "        if content_type and (content_type.startswith('application/json') or content_type.endswith('+json')):",
        "            return json.dumps(body).encode('utf-8'), content_type",
        "        if content_type and content_type.startswith('text/csv'):",
        "            return str(body).encode('utf-8'), content_type",
        "        if content_type and content_type.startswith('text/plain'):",
        "            return str(body).encode('utf-8'), content_type",
        "        return json.dumps(body).encode('utf-8'), content_type",
        "",
        "    def _decode_body(self, content_type: str, data: bytes) -> object:",
        "        if not content_type:",
        "            return data",
        "        if not data:",
        "            return None",
        "        if content_type.startswith('application/x-ndjson'):",
        "            return [json.loads(line) for line in data.splitlines() if line]",
        "        if content_type.startswith('application/stream+json'):",
        "            return [json.loads(line) for line in data.splitlines() if line]",
        "        if content_type.startswith('application/json') or content_type.endswith('+json'):",
        "            try:",
        "                return json.loads(data)",
        "            except json.JSONDecodeError as exc:",
        "                raise DecodeError('Failed to decode JSON') from exc",
        "        if content_type.startswith('application/x-www-form-urlencoded'):",
        "            return data.decode('utf-8')",
        "        if content_type.startswith('text/csv'):",
        "            return data.decode('utf-8')",
        "        if content_type.startswith('text/plain'):",
        "            return data.decode('utf-8')",
        "        return data",
        "",
        "    def _encode_ndjson(self, body: object) -> bytes:",
        "        if isinstance(body, Iterable) and not isinstance(body, (str, bytes, bytearray)):",
        "            lines = [json.dumps(item) for item in body]",
        "            return ('\\n'.join(lines) + '\\n').encode('utf-8')",
        "        return json.dumps(body).encode('utf-8')",
        "",
        "    def _encode_multipart(self, body: Mapping[str, object]) -> tuple[bytes, str]:",
        "        boundary = 'clientify-boundary'",
        "        parts: list[bytes] = []",
        "        for key, value in body.items():",
        "            parts.append(f'--{boundary}'.encode('utf-8'))",
        "            parts.append(f'Content-Disposition: form-data; name=\"{key}\"'.encode('utf-8'))",
        "            parts.append(b'')",
        "            parts.append(str(value).encode('utf-8'))",
        "        parts.append(f'--{boundary}--'.encode('utf-8'))",
        "        return b'\\r\\n'.join(parts), boundary",
        "",
        "    def _iter_event_stream_lines(self, response: SyncResponse) -> Iterator[str]:",
        "        try:",
        "            iterator = response.iter_bytes()",
        "        except Exception:",
        "            return iter(())",
        "        buffer = ''",
        "        for chunk in iterator:",
        "            buffer += chunk.decode('utf-8')",
        "            while '\\n\\n' in buffer:",
        "                part, buffer = buffer.split('\\n\\n', 1)",
        "                for line in part.splitlines():",
        "                    yield line",
        "        if buffer:",
        "            for line in buffer.splitlines():",
        "                yield line",
        "",
        "    async def _aiter_event_stream_lines(self, response: AsyncResponse) -> AsyncIterator[str]:",
        "        buffer = ''",
        "        async for chunk in response.aiter_bytes():",
        "            buffer += chunk.decode('utf-8')",
        "            while '\\n\\n' in buffer:",
        "                part, buffer = buffer.split('\\n\\n', 1)",
        "                for line in part.splitlines():",
        "                    yield line",
        "        if buffer:",
        "            for line in buffer.splitlines():",
        "                yield line",
        "",
    ]


def emit_request_impl(sync: bool) -> list[str]:
    """Generate the request() method implementation for a client class.

    This generates the main request dispatch method that handles:
    - Parameter extraction (path, query, header, cookie)
    - Header construction
    - Content-type detection
    - Accept header handling
    - URL building
    - Body encoding
    - Backend request execution
    - Response decoding
    - Success/error response wrapping
    """
    if sync:
        return [
            "    def request(",
            "        self,",
            "        method: str,",
            "        url: str,",
            "        *,",
            "        params: object | None = None,",
            "        body: object | None = None,",
            "        content_type: str | None = None,",
            "        expected_statuses: set[str] | None = None,",
            "        timeout: float | None = None,",
            "    ) -> SuccessResponse[object] | ErrorResponse[object]:",
            "        params_map = params if isinstance(params, Mapping) else {}",
            "        path_params = params_map.get('path') if params_map else None",
            "        query_params = params_map.get('query') if params_map else None",
            "        header_params = params_map.get('header') if params_map else None",
            "        cookie_params = params_map.get('cookie') if params_map else None",
            "        headers = dict(self._headers)",
            "        if header_params:",
            "            headers.update({str(k): str(v) for k, v in header_params.items()})",
            "        if cookie_params:",
            "            cookie_header = '; '.join(",
            '                f"{key}={value}" for key, value in cookie_params.items()',
            "            )",
            "            if cookie_header:",
            "                if 'cookie' not in {k.lower() for k in headers.keys()}:",
            "                    headers['Cookie'] = cookie_header",
            "        if content_type is None:",
            "            content_types = self._request_content_types.get((method, url))",
            "            if content_types and len(content_types) == 1:",
            "                content_type = content_types[0]",
            "        if content_type:",
            "            headers['Content-Type'] = content_type",
            "        if 'accept' not in {k.lower() for k in headers.keys()}:",
            "            accept_types = self._accept_types.get((method, url))",
            "            if accept_types:",
            "                headers['Accept'] = ', '.join(accept_types)",
            "        url = self._build_url(url, path_params, query_params)",
            "        payload, content_type = self._encode_body(body, content_type)",
            "        try:",
            "            backend_response = self._backend.request(",
            "                method=method,",
            "                url=url,",
            "                headers=headers,",
            "                content=payload,",
            "                timeout=timeout,",
            "            )",
            "        except Exception as exc:",
            "            backend_name = type(self._backend).__name__",
            "            raise TransportError(f'Backend request failed: {backend_name}') from exc",
            "        response_headers = getattr(backend_response, 'headers', None) or {}",
            "        content_type_header = response_headers.get('content-type', '')",
            "        if content_type_header.startswith('text/event-stream'):",
            "            body_value = self._iter_event_stream_lines(backend_response)",
            "        else:",
            "            data = b''.join(backend_response.iter_bytes())",
            "            body_value = self._decode_body(content_type_header, data)",
            "        if expected_statuses is None:",
            "            expected_statuses = self._expected_statuses.get((method, url))",
            "        if 200 <= backend_response.status_code < 300:",
            "            api_response = SuccessResponse[object]()",
            "            api_response.status = backend_response.status_code",
            "            api_response.headers = response_headers",
            "            api_response.body = body_value",
            "            return api_response",
            "        if self._raise_on_unexpected_status:",
            "            expected = expected_statuses or set()",
            "            if expected and str(backend_response.status_code) not in expected:",
            "                raise ClientError(f'Unexpected status: {backend_response.status_code}')",
            "        api_response = ErrorResponse[object]()",
            "        api_response.status = backend_response.status_code",
            "        api_response.headers = response_headers",
            "        api_response.body = body_value",
            "        return api_response",
            "",
        ]
    return [
        "    async def request(",
        "        self,",
        "        method: str,",
        "        url: str,",
        "        *,",
        "        params: object | None = None,",
        "        body: object | None = None,",
        "        content_type: str | None = None,",
        "        expected_statuses: set[str] | None = None,",
        "        timeout: float | None = None,",
        "    ) -> SuccessResponse[object] | ErrorResponse[object]:",
        "        params_map = params if isinstance(params, Mapping) else {}",
        "        path_params = params_map.get('path') if params_map else None",
        "        query_params = params_map.get('query') if params_map else None",
        "        header_params = params_map.get('header') if params_map else None",
        "        cookie_params = params_map.get('cookie') if params_map else None",
        "        headers = dict(self._headers)",
        "        if header_params:",
        "            headers.update({str(k): str(v) for k, v in header_params.items()})",
        "        if cookie_params:",
        "            cookie_header = '; '.join(",
        '                f"{key}={value}" for key, value in cookie_params.items()',
        "            )",
        "            if cookie_header:",
        "                if 'cookie' not in {k.lower() for k in headers.keys()}:",
        "                    headers['Cookie'] = cookie_header",
        "        if content_type is None:",
        "            content_types = self._request_content_types.get((method, url))",
        "            if content_types and len(content_types) == 1:",
        "                content_type = content_types[0]",
        "        if content_type:",
        "            headers['Content-Type'] = content_type",
        "        if 'accept' not in {k.lower() for k in headers.keys()}:",
        "            accept_types = self._accept_types.get((method, url))",
        "            if accept_types:",
        "                headers['Accept'] = ', '.join(accept_types)",
        "        url = self._build_url(url, path_params, query_params)",
        "        payload, content_type = self._encode_body(body, content_type)",
        "        try:",
        "            backend_response = await self._backend.request(",
        "                method=method,",
        "                url=url,",
        "                headers=headers,",
        "                content=payload,",
        "                timeout=timeout,",
        "            )",
        "        except Exception as exc:",
        "            backend_name = type(self._backend).__name__",
        "            raise TransportError(f'Backend request failed: {backend_name}') from exc",
        "        response_headers = getattr(backend_response, 'headers', None) or {}",
        "        content_type_header = response_headers.get('content-type', '')",
        "        if content_type_header.startswith('text/event-stream'):",
        "            body_value = self._aiter_event_stream_lines(backend_response)",
        "        else:",
        "            chunks: list[bytes] = []",
        "            async for chunk in backend_response.aiter_bytes():",
        "                chunks.append(chunk)",
        "            data = b''.join(chunks)",
        "            body_value = self._decode_body(content_type_header, data)",
        "        if expected_statuses is None:",
        "            expected_statuses = self._expected_statuses.get((method, url))",
        "        if 200 <= backend_response.status_code < 300:",
        "            api_response = SuccessResponse[object]()",
        "            api_response.status = backend_response.status_code",
        "            api_response.headers = response_headers",
        "            api_response.body = body_value",
        "            return api_response",
        "        if self._raise_on_unexpected_status:",
        "            expected = expected_statuses or set()",
        "            if expected and str(backend_response.status_code) not in expected:",
        "                raise ClientError(f'Unexpected status: {backend_response.status_code}')",
        "        api_response = ErrorResponse[object]()",
        "        api_response.status = backend_response.status_code",
        "        api_response.headers = response_headers",
        "        api_response.body = body_value",
        "        return api_response",
        "",
    ]
